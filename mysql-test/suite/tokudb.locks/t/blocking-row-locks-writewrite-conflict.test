# Tokutek
# Blocking row lock tests;
# Generated by blocking-row-locks-testgen.py on 2011-09-25;

# prepare with some common parameters
set storage_engine=tokudb;
connect(conn2, localhost, root);
connection default;

# drop old table, generate new one. 4 rows
--disable_warnings
drop table if exists t;
--enable_warnings
create table t (a int primary key, b int);
insert ignore t values(1, 1);
insert ignore t values(2, 4);
insert ignore t values(3, 9);
insert ignore t values(4, 16);
insert ignore t values(5, 25);
insert ignore t values(6, 36);

# testing with timeout 0
set global tokudb_lock_timeout=0;

# testing each point query vs each point query
# testing conflict "select for update" vs. "select for update"
connection default;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
connection default;
commit;
connection conn2;
select * from t where a=1 for update;
select * from t;
connection default;

# testing conflict "select for update" vs. "update"
connection default;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
connection default;
commit;
connection conn2;
update t set b=b where a=1;
select * from t;
connection default;

# testing conflict "select for update" vs. "insert"
connection default;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
connection default;
commit;
connection conn2;
insert ignore t values(1, 100);
select * from t;
connection default;

# testing conflict "select for update" vs. "replace"
connection default;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
connection default;
commit;
connection conn2;
replace t values(1, 100);
select * from t;
connection default;

# testing range query "select for update" vs "select for update"
connection default;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
connection default;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
select * from t;
connection default;

# testing range query "update" vs "select for update"
connection default;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
connection default;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
select * from t;
connection default;

# testing conflict "update" vs. "select for update"
connection default;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
connection default;
commit;
connection conn2;
select * from t where a=1 for update;
select * from t;
connection default;

# testing conflict "update" vs. "update"
connection default;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
connection default;
commit;
connection conn2;
update t set b=b where a=1;
select * from t;
connection default;

# testing conflict "update" vs. "insert"
connection default;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
connection default;
commit;
connection conn2;
insert ignore t values(1, 100);
select * from t;
connection default;

# testing conflict "update" vs. "replace"
connection default;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
connection default;
commit;
connection conn2;
replace t values(1, 100);
select * from t;
connection default;

# testing range query "select for update" vs "update"
connection default;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
connection default;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
select * from t;
connection default;

# testing range query "update" vs "update"
connection default;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
connection default;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
select * from t;
connection default;

# testing conflict "insert" vs. "select for update"
connection default;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
connection default;
commit;
connection conn2;
select * from t where a=1 for update;
select * from t;
connection default;

# testing conflict "insert" vs. "update"
connection default;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
connection default;
commit;
connection conn2;
update t set b=b where a=1;
select * from t;
connection default;

# testing conflict "insert" vs. "insert"
connection default;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
connection default;
commit;
connection conn2;
insert ignore t values(1, 100);
select * from t;
connection default;

# testing conflict "insert" vs. "replace"
connection default;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
connection default;
commit;
connection conn2;
replace t values(1, 100);
select * from t;
connection default;

# testing range query "select for update" vs "insert"
connection default;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
connection default;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
select * from t;
connection default;

# testing range query "update" vs "insert"
connection default;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
connection default;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
select * from t;
connection default;

# testing conflict "replace" vs. "select for update"
connection default;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
connection default;
commit;
connection conn2;
select * from t where a=1 for update;
select * from t;
connection default;

# testing conflict "replace" vs. "update"
connection default;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
connection default;
commit;
connection conn2;
update t set b=b where a=1;
select * from t;
connection default;

# testing conflict "replace" vs. "insert"
connection default;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
connection default;
commit;
connection conn2;
insert ignore t values(1, 100);
select * from t;
connection default;

# testing conflict "replace" vs. "replace"
connection default;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
connection default;
commit;
connection conn2;
replace t values(1, 100);
select * from t;
connection default;

# testing range query "select for update" vs "replace"
connection default;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
connection default;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
select * from t;
connection default;

# testing range query "update" vs "replace"
connection default;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
connection default;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
select * from t;
connection default;

# testing range query "select for update" vs range query "select for update"
connection default;
begin;

select * from t where a>=2 and a<=4 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 and a<=3 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=6 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
select * from t where a>=5 for update;
connection default;
commit;
connection conn2;
select * from t where a>=0 and a<=3 for update;
select * from t where a>=3 and a<=6 for update;
select * from t where a<=2 for update;
select * from t;
connection default;

# testing range query "select for update" vs range query "update"
connection default;
begin;

select * from t where a>=2 and a<=4 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0 and a<=3;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=3 and a<=6;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
update t set b=b where a>=5;
connection default;
commit;
connection conn2;
update t set b=b where a>=0 and a<=3;
update t set b=b where a>=3 and a<=6;
update t set b=b where a<=2;
select * from t;
connection default;

# testing range query "update" vs range query "select for update"
connection default;
begin;

update t set b=b where a>=2 and a<=4;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 and a<=3 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=6 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
select * from t where a>=5 for update;
connection default;
commit;
connection conn2;
select * from t where a>=0 and a<=3 for update;
select * from t where a>=3 and a<=6 for update;
select * from t where a<=2 for update;
select * from t;
connection default;

# testing range query "update" vs range query "update"
connection default;
begin;

update t set b=b where a>=2 and a<=4;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0 and a<=3;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=3 and a<=6;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
update t set b=b where a>=5;
connection default;
commit;
connection conn2;
update t set b=b where a>=0 and a<=3;
update t set b=b where a>=3 and a<=6;
update t set b=b where a<=2;
select * from t;
connection default;

# testing with timeout 500000
set global tokudb_lock_timeout=500000;

# testing each point query vs each point query
# testing conflict "select for update" vs. "select for update"
connection default;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
connection default;
commit;
connection conn2;
select * from t where a=1 for update;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
select * from t where a=1 for update;
connection conn2;
send  select * from t where a=1 for update;
connection default;
commit;
connection conn2;
reap;
# testing conflict "select for update" vs. "update"
connection default;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
connection default;
commit;
connection conn2;
update t set b=b where a=1;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
select * from t where a=1 for update;
connection conn2;
send  update t set b=b where a=1;
connection default;
commit;
connection conn2;
reap;
# testing conflict "select for update" vs. "insert"
connection default;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
connection default;
commit;
connection conn2;
insert ignore t values(1, 100);
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
select * from t where a=1 for update;
connection conn2;
send  insert ignore t values(1, 175);
connection default;
commit;
connection conn2;
reap;
# testing conflict "select for update" vs. "replace"
connection default;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
connection default;
commit;
connection conn2;
replace t values(1, 100);
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
select * from t where a=1 for update;
connection conn2;
send  replace t values(1, 175);
connection default;
commit;
connection conn2;
reap;
# testing range query "select for update" vs "select for update"
connection default;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
connection default;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
select * from t where a=1 for update;
connection conn2;
send  select * from t where a<=2 for update;
connection default;
commit;
connection conn2;
reap;
# testing range query "update" vs "select for update"
connection default;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
connection default;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
select * from t where a=1 for update;
connection conn2;
send  update t set b=b where a<=2;
connection default;
commit;
connection conn2;
reap;
# testing conflict "update" vs. "select for update"
connection default;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
connection default;
commit;
connection conn2;
select * from t where a=1 for update;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
update t set b=b where a=1;
connection conn2;
send  select * from t where a=1 for update;
connection default;
commit;
connection conn2;
reap;
# testing conflict "update" vs. "update"
connection default;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
connection default;
commit;
connection conn2;
update t set b=b where a=1;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
update t set b=b where a=1;
connection conn2;
send  update t set b=b where a=1;
connection default;
commit;
connection conn2;
reap;
# testing conflict "update" vs. "insert"
connection default;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
connection default;
commit;
connection conn2;
insert ignore t values(1, 100);
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
update t set b=b where a=1;
connection conn2;
send  insert ignore t values(1, 175);
connection default;
commit;
connection conn2;
reap;
# testing conflict "update" vs. "replace"
connection default;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
connection default;
commit;
connection conn2;
replace t values(1, 100);
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
update t set b=b where a=1;
connection conn2;
send  replace t values(1, 175);
connection default;
commit;
connection conn2;
reap;
# testing range query "select for update" vs "update"
connection default;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
connection default;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
update t set b=b where a=1;
connection conn2;
send  select * from t where a<=2 for update;
connection default;
commit;
connection conn2;
reap;
# testing range query "update" vs "update"
connection default;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
connection default;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
update t set b=b where a=1;
connection conn2;
send  update t set b=b where a<=2;
connection default;
commit;
connection conn2;
reap;
# testing conflict "insert" vs. "select for update"
connection default;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
connection default;
commit;
connection conn2;
select * from t where a=1 for update;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
insert ignore t values(1, 150);
connection conn2;
send  select * from t where a=1 for update;
connection default;
commit;
connection conn2;
reap;
# testing conflict "insert" vs. "update"
connection default;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
connection default;
commit;
connection conn2;
update t set b=b where a=1;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
insert ignore t values(1, 150);
connection conn2;
send  update t set b=b where a=1;
connection default;
commit;
connection conn2;
reap;
# testing conflict "insert" vs. "insert"
connection default;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
connection default;
commit;
connection conn2;
insert ignore t values(1, 100);
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
insert ignore t values(1, 150);
connection conn2;
send  insert ignore t values(1, 175);
connection default;
commit;
connection conn2;
reap;
# testing conflict "insert" vs. "replace"
connection default;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
connection default;
commit;
connection conn2;
replace t values(1, 100);
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
insert ignore t values(1, 150);
connection conn2;
send  replace t values(1, 175);
connection default;
commit;
connection conn2;
reap;
# testing range query "select for update" vs "insert"
connection default;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
connection default;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
insert ignore t values(1, 150);
connection conn2;
send  select * from t where a<=2 for update;
connection default;
commit;
connection conn2;
reap;
# testing range query "update" vs "insert"
connection default;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
connection default;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
insert ignore t values(1, 150);
connection conn2;
send  update t set b=b where a<=2;
connection default;
commit;
connection conn2;
reap;
# testing conflict "replace" vs. "select for update"
connection default;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
connection default;
commit;
connection conn2;
select * from t where a=1 for update;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
replace t values(1, 150);
connection conn2;
send  select * from t where a=1 for update;
connection default;
commit;
connection conn2;
reap;
# testing conflict "replace" vs. "update"
connection default;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
connection default;
commit;
connection conn2;
update t set b=b where a=1;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
replace t values(1, 150);
connection conn2;
send  update t set b=b where a=1;
connection default;
commit;
connection conn2;
reap;
# testing conflict "replace" vs. "insert"
connection default;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
connection default;
commit;
connection conn2;
insert ignore t values(1, 100);
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
replace t values(1, 150);
connection conn2;
send  insert ignore t values(1, 175);
connection default;
commit;
connection conn2;
reap;
# testing conflict "replace" vs. "replace"
connection default;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
connection default;
commit;
connection conn2;
replace t values(1, 100);
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
replace t values(1, 150);
connection conn2;
send  replace t values(1, 175);
connection default;
commit;
connection conn2;
reap;
# testing range query "select for update" vs "replace"
connection default;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
connection default;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
replace t values(1, 150);
connection conn2;
send  select * from t where a<=2 for update;
connection default;
commit;
connection conn2;
reap;
# testing range query "update" vs "replace"
connection default;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
connection default;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
replace t values(1, 150);
connection conn2;
send  update t set b=b where a<=2;
connection default;
commit;
connection conn2;
reap;
# testing range query "select for update" vs range query "select for update"
connection default;
begin;

select * from t where a>=2 and a<=4 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 and a<=3 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=6 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
select * from t where a>=5 for update;
connection default;
commit;
connection conn2;
select * from t where a>=0 and a<=3 for update;
select * from t where a>=3 and a<=6 for update;
select * from t where a<=2 for update;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
select * from t where a>=2 and a<=4 for update;
connection conn2;
send  select * from t where a>=0 and a<=3 for update;
connection default;
commit;
connection conn2;
reap;
# testing range query "select for update" vs range query "update"
connection default;
begin;

select * from t where a>=2 and a<=4 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0 and a<=3;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=3 and a<=6;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
update t set b=b where a>=5;
connection default;
commit;
connection conn2;
update t set b=b where a>=0 and a<=3;
update t set b=b where a>=3 and a<=6;
update t set b=b where a<=2;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
select * from t where a>=2 and a<=4 for update;
connection conn2;
send  update t set b=b where a>=0 and a<=3;
connection default;
commit;
connection conn2;
reap;
# testing range query "update" vs range query "select for update"
connection default;
begin;

update t set b=b where a>=2 and a<=4;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 and a<=3 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=6 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
select * from t where a>=5 for update;
connection default;
commit;
connection conn2;
select * from t where a>=0 and a<=3 for update;
select * from t where a>=3 and a<=6 for update;
select * from t where a<=2 for update;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
update t set b=b where a>=2 and a<=4;
connection conn2;
send  select * from t where a>=0 and a<=3 for update;
connection default;
commit;
connection conn2;
reap;
# testing range query "update" vs range query "update"
connection default;
begin;

update t set b=b where a>=2 and a<=4;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0 and a<=3;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=3 and a<=6;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
update t set b=b where a>=5;
connection default;
commit;
connection conn2;
update t set b=b where a>=0 and a<=3;
update t set b=b where a>=3 and a<=6;
update t set b=b where a<=2;
select * from t;
connection default;

# check that an early commit allows a blocked
# transaction to complete
connection default;
begin;
update t set b=b where a>=2 and a<=4;
connection conn2;
send  update t set b=b where a>=0 and a<=3;
connection default;
commit;
connection conn2;
reap;
# clean it all up
drop table t;
set global tokudb_lock_timeout=30000000;

