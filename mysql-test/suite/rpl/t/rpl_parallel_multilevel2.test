--source include/have_innodb.inc
--let $rpl_topology=1->2->3
--source include/rpl_init.inc

--echo *** MDEV-7668: Intermediate master groups CREATE with INSERT, causing parallel replication failure ***

--connection server_1
SET @old_updates= @@GLOBAL.binlog_direct_non_transactional_updates;
SET GLOBAL binlog_direct_non_transactional_updates=OFF;
SET SESSION binlog_direct_non_transactional_updates=OFF;
ALTER TABLE mysql.gtid_slave_pos ENGINE=InnoDB;
CREATE TABLE t1 (a int PRIMARY KEY, b INT) ENGINE=InnoDB;
--save_master_pos

--connection server_2
--sync_with_master
--save_master_pos
--source include/stop_slave.inc
SET @old_parallel_threads=@@GLOBAL.slave_parallel_threads;
SET GLOBAL slave_parallel_threads=10;
SET @old_commit_count=@@GLOBAL.binlog_commit_wait_count;
SET GLOBAL binlog_commit_wait_count=2;
SET @old_commit_usec=@@GLOBAL.binlog_commit_wait_usec;
SET GLOBAL binlog_commit_wait_usec=2000000;
SET @old_updates= @@GLOBAL.binlog_direct_non_transactional_updates;
SET GLOBAL binlog_direct_non_transactional_updates=OFF;
SET SESSION binlog_direct_non_transactional_updates=OFF;
CHANGE MASTER TO master_use_gtid=current_pos;

# Get Initial status measurements
# we take out measurements from server_2 as that's where
# the its critical that separate binlog_group_commits occur
SELECT variable_value INTO @group_commits FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commits';
SELECT variable_value INTO @group_commit_trigger_count FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commit_trigger_count';
SELECT variable_value INTO @group_commit_trigger_timeout FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commit_trigger_timeout';
SELECT variable_value INTO @group_commit_trigger_lock_wait FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commit_trigger_lock_wait';

# Note: binlog_group_commits is counted at the start of the group and group_commit_trigger_* is
# counted near when the groups its finalised.


--connection server_3
--sync_with_master
--save_master_pos
SET @old_parallel_threads=@@GLOBAL.slave_parallel_threads;
--source include/stop_slave.inc
SET GLOBAL slave_parallel_threads=10;
CHANGE MASTER TO master_use_gtid=current_pos;


--connection server_1

BEGIN;
CREATE TEMPORARY TABLE t2 (a INT PRIMARY KEY) ENGINE=MEMORY;
COMMIT;
INSERT INTO t2 VALUES (1);
INSERT INTO t1 SELECT a, a*10 FROM t2;
DROP TABLE t2;
--source include/save_master_gtid.inc

--connection server_2
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc
SELECT * FROM t1 ORDER BY a;

--connection server_3
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc
SELECT * FROM t1 ORDER BY a;

# Measure status(es)
--connection server_2
# A create tempory table being a DDL needs to be its own group for SBR.
# RBR has table maps which indicate that the temp table needs to be created first.
# In SBR the first insert from server 1 is begins the second group. The second 
# insert statement depends on the first it has to be ordered in a third group.
# 1 group is generated in row based replication as the insert into t1 is values rather than references to t2
# and the table map indicates that the temp table needs to be created first.
# 3 groups are generated in mixed/statement based replication
# All groups result in a binlog_group_commit_trigger_timeout as no other
# transactions are pushed to server_2 so therefore non_timeout_triggers is 0.
SELECT IF((commits.variable_value - @group_commits)=IF(@@binlog_format='ROW',1,3), "OK", "Not 1 (row) or 3 (mixed/statement replication) groups"),
 ((commits.variable_value - @group_commits) - (trigger_timeout.variable_value - @group_commit_trigger_timeout)) as non_timeout_triggers
 FROM information_schema.global_status commits
 JOIN  information_schema.global_status trigger_timeout
 WHERE commits.variable_name = 'binlog_group_commits'
 AND trigger_timeout.variable_name = 'binlog_group_commit_trigger_timeout';
SELECT variable_value - @group_commit_trigger_count as trigger_count FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commit_trigger_count';
SELECT variable_value - @group_commit_trigger_lock_wait as trigger_lock_wait FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commit_trigger_lock_wait';

# Clean up

--connection server_2
--source include/stop_slave.inc
SET GLOBAL slave_parallel_threads=@old_parallel_threads;
SET GLOBAL binlog_commit_wait_count=@old_commit_count;
SET GLOBAL binlog_commit_wait_usec=@old_commit_usec;
SET GLOBAL binlog_direct_non_transactional_updates= @old_updates;
--source include/start_slave.inc

--connection server_3
--source include/stop_slave.inc
SET GLOBAL slave_parallel_threads=@old_parallel_threads;
--source include/start_slave.inc

--connection server_1
SET GLOBAL binlog_direct_non_transactional_updates= @old_updates;
CALL mtr.add_suppression("Statement accesses nontransactional table as well as transactional or temporary table");
DROP TABLE t1;

--source include/rpl_end.inc
