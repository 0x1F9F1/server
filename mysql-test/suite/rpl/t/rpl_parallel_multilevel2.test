--source include/have_innodb.inc
--let $rpl_topology=1->2->3
--source include/rpl_init.inc

--echo *** MDEV-7668: Intermediate master groups CREATE with INSERT, causing parallel replication failure ***

--connection server_1
SET @old_updates= @@GLOBAL.binlog_direct_non_transactional_updates;
SET GLOBAL binlog_direct_non_transactional_updates=OFF;
SET SESSION binlog_direct_non_transactional_updates=OFF;
ALTER TABLE mysql.gtid_slave_pos ENGINE=InnoDB;
CREATE TABLE t1 (a int PRIMARY KEY, b INT) ENGINE=InnoDB;
--save_master_pos

--connection server_2
--sync_with_master
--save_master_pos
--source include/stop_slave.inc
SET @old_parallel_threads=@@GLOBAL.slave_parallel_threads;
SET GLOBAL slave_parallel_threads=10;
SET @old_commit_count=@@GLOBAL.binlog_commit_wait_count;
SET GLOBAL binlog_commit_wait_count=2;
SET @old_commit_usec=@@GLOBAL.binlog_commit_wait_usec;
SET GLOBAL binlog_commit_wait_usec=2000000;
SET @old_updates= @@GLOBAL.binlog_direct_non_transactional_updates;
SET GLOBAL binlog_direct_non_transactional_updates=OFF;
SET SESSION binlog_direct_non_transactional_updates=OFF;
CHANGE MASTER TO master_use_gtid=current_pos;

# Get Initial status measurements
# we take out measurements from server_2 as that's where
# the its critical that 3 separate binlog_group_commits occur
SELECT variable_value INTO @group_commits FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commits';
SELECT variable_value INTO @group_commit_reason_count FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commit_reason_count';
SELECT variable_value INTO @group_commit_reason_usec FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commit_reason_usec';
SELECT variable_value INTO @group_commit_reason_transaction FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commit_reason_transaction';
SELECT variable_value INTO @group_commit_reason_immediate FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commit_reason_immediate';

# Note: binlog_group_commits is counted at the start of the group and group_commit_reason_* is
# counted near when the groups its finalised.


--connection server_3
--sync_with_master
--save_master_pos
SET @old_parallel_threads=@@GLOBAL.slave_parallel_threads;
--source include/stop_slave.inc
SET GLOBAL slave_parallel_threads=10;
CHANGE MASTER TO master_use_gtid=current_pos;


--connection server_1

BEGIN;
CREATE TEMPORARY TABLE t2 (a INT PRIMARY KEY) ENGINE=MEMORY;
COMMIT;
INSERT INTO t2 VALUES (1);
INSERT INTO t1 SELECT a, a*10 FROM t2;
DROP TABLE t2;
--source include/save_master_gtid.inc

--connection server_2
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc
SELECT * FROM t1 ORDER BY a;

--connection server_3
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc
SELECT * FROM t1 ORDER BY a;

# Measure status(es)
--connection server_2
SELECT IF((commits.variable_value - @group_commits) IN (1,3), "OK", "Not 1 or 3 groups"),
 ((commits.variable_value - @group_commits) - (reason_usec.variable_value - @group_commit_reason_usec)) as diff
 FROM information_schema.global_status commits
 JOIN  information_schema.global_status reason_usec
 WHERE commits.variable_name = 'binlog_group_commits'
 AND reason_usec.variable_name = 'binlog_group_commit_reason_usec';
SELECT variable_value - @group_commit_reason_count FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commit_reason_count';
SELECT variable_value - @group_commit_reason_transaction FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commit_reason_transaction';
SELECT variable_value - @group_commit_reason_immediate FROM information_schema.global_status
 WHERE variable_name = 'binlog_group_commit_reason_immediate';

# Clean up

--connection server_2
--source include/stop_slave.inc
SET GLOBAL slave_parallel_threads=@old_parallel_threads;
SET GLOBAL binlog_commit_wait_count=@old_commit_count;
SET GLOBAL binlog_commit_wait_usec=@old_commit_usec;
SET GLOBAL binlog_direct_non_transactional_updates= @old_updates;
--source include/start_slave.inc

--connection server_3
--source include/stop_slave.inc
SET GLOBAL slave_parallel_threads=@old_parallel_threads;
--source include/start_slave.inc

--connection server_1
SET GLOBAL binlog_direct_non_transactional_updates= @old_updates;
CALL mtr.add_suppression("Statement accesses nontransactional table as well as transactional or temporary table");
DROP TABLE t1;

--source include/rpl_end.inc
